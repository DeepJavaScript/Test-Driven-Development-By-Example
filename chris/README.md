# TDD

## 環境

node v16.14.0
npm 8.3.1
vite 2.9.9
vitest 0.14.1

## 步驟

1. 建立小小的測試
2. 執行測試，得到紅燈
3. 對程式碼進行小小修改
4. 執行所有測試，並通過所有測試，得到綠燈
5. 重構程式，消除重複的程式碼

## 記事

### Ch1

- 讓單元測試結果，成為 build 的延伸
- 依賴 (dependency) 與 重複 (duplication) 的觀念

> **重複 (duplication)**
> - 測試 code 與產品 code 之間有著相依性。
> - 目的: 在改動其中一個時，不更改另外一個 => 解除相依
> - 如果程式碼「依賴」於某一個套件時，就會出現「重複」，透過物件的抽象設計，可以解掉依賴，降低重複
> - 撰寫下一個測試之前，消除現有程式中的重複設計，確保滿足下一個測試的過程中，只需要針對一個變因調整程式
> 

### Ch2

測試驅動開發循環

1. 寫一個測試 -> 紅燈
2. 滿足綠燈的前提糙 code -> 綠燈 => 可用
3. 整理目前的糙 code -> 綠燈 => 簡潔

目的: 交付簡潔可用的程式碼

> architecture-driven development 方式完全相反
> 它是先處理簡䌇，再處理可用。

在此的退化，因為「先思考可用，再思考簡潔」的邏輯，選擇了不簡潔的做法。
目的在於先消除 side effect。 

### Ch3

有一個整數，並對它 +1 並不希望原本的整數有變化，而是得到一個新的整數結果。

可以把物件當作數值來使用，像我們使用 `Dollar` 一樣，這種做法稱作數值物件 (Value Object)。

#### 數值物件

- 一旦值透過建構式設定就不再改變。
- 就是所有對它的操作，都要回傳一個新的物件。(就像 Ch2 做的那樣)
- 要實作 `equals()` ，要依內部值的內容決定是否與另一個物件相同。
- 如果把數值物件當作 hash table 的 key 來用的話，除了實作 `equals()` 還要實作 `hashCode()`

### 測試驅動的三角定位法

- 只在兩個以上的例子時，才開始寫實際的產品 code
- 暫時忽略測試 code 與產品 code之間的重複 (就是那個直接 `return true`)
- 只有為了第二個例子要通過，才寫通用一點的產品 code

使用時機

- 不知道怎麼重構時，先重新思考再加一個不同的測試
- 對設計概念沒有靈感時，三角定位法可以提供不同的思路

> 三角定位法，可以理解成夾擊定理，利用邊界條件找出可行的區間。
